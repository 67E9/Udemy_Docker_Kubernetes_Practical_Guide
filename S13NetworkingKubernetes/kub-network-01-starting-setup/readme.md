# check prerequisites

start Docker Desktop

minikube status
- check if minikube is running

minikube start --driver=docker 
- start minikube

kubectl get deployments
kubectl get services
- check if there is a running deployment, custom service

# users-app

note: replace axios calls with dummy objects of the correct type until the auth app is available

cd users-api
docker build -t pmssdtest/kub-demo-users .
docker push pmssdtest/kub-demo-users          
kubectl apply -f=kubernetes/user-deployment.yaml

# service

note: gives us stable address and allow aoutside world access

kubectl apply -f=kubernetes/user-service.yaml

minikube service users-service => get external access in minikube

# preparation for auth-app

notes: 
- axios calls in users-app where commented in again
- then, the url for this case was made configurable using env vars

# auth-app

docker build -t pmssdtest/kub-demo-auth auth-api/.
docker push pmssdtest/kub-demo-auth

note: add second image to the pod inside user-deployment
=> two containers in one pod and deployment
=> refer to user-deployment.yaml

# update user-app
docker build -t pmssdtest/kub-demo-users users-api/.
docker push pmssdtest/kub-demo-users

# pod internal communication between containers

notes: 
- use localhost 
- refer to "env" in user-deployment.yaml

kubectl apply -f=kubernetes/user-deployment.yaml

kubectl get pods
NAME                              READY   STATUS    RESTARTS   AGE
users-deployment-bd6b69b6-hncm4   2/2     Running   0          2m41s
=> 2/2 means both containers are running

# sidenote: debugging, how to get logs?
kubectl logs <podname> name=<myLabel> ctl

# separate deployments for users and auth apis

auth-api get their own deployment and service:
- auth-service.yaml
- auth-depyloment.yaml

auth-service is CLusterIP to only expose port 80 internally

kubectl apply -f=kubernetes/auth-service.yaml -f=kubernetes/auth-deployment.yaml

# how to rach a separate pod:
To reach auth api you could use the internal IP of auth service (kubectl get service) as a env var, but:
- you can alternatively use _autogenerated env vars_
- service name in all caps with dashes replaced by underscores + _SERVICE_HOST e.g. AUTH_SERVICE_SERVICE_HOST

OR more conveniently:

- use _core dns_
- cluster internal domain names
- auto-generates domain names for all services in cluster
- address = service-name.namespace 
    e.g. auth-service.default

lookup namespaces:

kubectl get namespaces

=> minikube by default adds services to namespace=default

# best solution?

two containers should only be in the same pod, if they are tightly coupled 

options:
- manually look up IP of service
- use autogenerated env vars (..._SERVICE_HOST)
- use auto-generated domain names of service (core dns)

# frontend
docker build -t pmssdtest/kub-demo-frontend frontend\.
kubectl apply -f=kubernetes\frontend-deployment.yaml -f=kubernetes\frontend-service.yaml
minikube service frontend-service

# reverse proxy
To allow the frontend in the browser to reach the tasks-backend:
1. configure nginx.conf

  > \# reverse proxy to fowards calls from inside the react app to paths starting with /api/
  > \# the trailing / is important to pass on the correct path
  > \# this uses kubenetes core dns and works because nginx runs in the cluster (while the react app runs in the browser)
  > location /api/ {
  >   proxy_pass http//tasks-service.default:8000;
  > }

2. in the react app: use /api/ as base path for the api calls
